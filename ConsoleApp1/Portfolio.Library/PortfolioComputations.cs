using PricingLibrary.Computations;
using PricingLibrary.DataClasses;
using PricingLibrary.MarketDataFeed;
using PricingLibrary.TimeHandler;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Portfolio.Library
{
    public class PortfolioComputations
    {
        public static double[] SpotsArray(DataFeed dataFeed)
        {
            int numberOfShares = dataFeed.PriceList.Count;
            double[] allSpots = new double[numberOfShares];
            for (int i = 0; i < dataFeed.PriceList.Count; i++)
            {
                double spot = dataFeed.PriceList.ElementAt(i).Value;
                allSpots[i] = spot;
            }
            return allSpots;
        }

        public static bool RebalancingTime(DateTime date)
        {
            return date.DayOfWeek == DayOfWeek.Monday;
        }

        public static double SharesQuantity(double[] updatedWeights, double[] spots)
        {
            double sumOfQuantities = 0;
            for (int i = 0; i < updatedWeights.Length; i++)
            {
                sumOfQuantities += updatedWeights[i] * spots[i];
            }
            return sumOfQuantities;
        }


        //marketData : list of data feeds generated by CsvHandler
        public static List<double> PortfolioValues(TestParameters testParameters, List<DataFeed> marketData)
        {
            //premium computing
            Pricer pricer = new Pricer(testParameters);
            DateTime initialDate = marketData[0].Date;
            double initialTimeToMaturity = MathDateConverter.ConvertToMathDistance(initialDate, testParameters.BasketOption.Maturity);
            DataFeed initialDataFeed = marketData[0];
            double[] initialSpots = SpotsArray(initialDataFeed);
            PricingResults initialPriceResult = pricer.Price(initialTimeToMaturity, initialSpots);
            double[] deltas = initialPriceResult.Deltas;
            double premium = initialPriceResult.Price;
            //looping
            List<double> portfolio = new List<double>() { premium };
            double precedentPortfolioValue = premium;
            //portfolio.Add(premium);
            foreach (DataFeed dataFeed in marketData)
            {
                if (!dataFeed.Equals(initialDataFeed))
                {
                    double[] spots = SpotsArray(dataFeed);
                    double riskFreeRate = RiskFreeRateProvider.GetRiskFreeRateAccruedValue(initialDate, dataFeed.Date);
                    double portfolioValue = (precedentPortfolioValue - SharesQuantity(deltas, initialSpots)) * riskFreeRate + SharesQuantity(deltas, spots);

                    //Don't forget the rebalancing ; discarded for now
                    initialDate = dataFeed.Date;
                    // the line undeneath is what's done by portfolio update
                    double timeToMaturity = MathDateConverter.ConvertToMathDistance(dataFeed.Date, testParameters.BasketOption.Maturity);
                    PricingResults priceResult = pricer.Price(timeToMaturity, spots);
                    precedentPortfolioValue = portfolioValue;
                    //The line is below is what portfoliio update is supposed to do
                    //if (rebalacingday)
                   //{
                        deltas = priceResult.Deltas;
                    //}
                    initialSpots = spots;
                    portfolio.Add(portfolioValue);
                }
            }
            return portfolio;
        }
    }
}